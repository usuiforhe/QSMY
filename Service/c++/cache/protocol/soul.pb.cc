// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: soul.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "soul.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace cache {

namespace {

const ::google::protobuf::Descriptor* proSoul_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  proSoul_reflection_ = NULL;
const ::google::protobuf::Descriptor* proGetSoul_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  proGetSoul_reflection_ = NULL;
const ::google::protobuf::Descriptor* proGetSouls_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  proGetSouls_reflection_ = NULL;
const ::google::protobuf::Descriptor* proAddSoul_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  proAddSoul_reflection_ = NULL;
const ::google::protobuf::Descriptor* proAddSouls_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  proAddSouls_reflection_ = NULL;
const ::google::protobuf::Descriptor* proRemoveSoul_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  proRemoveSoul_reflection_ = NULL;
const ::google::protobuf::Descriptor* proRemoveSouls_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  proRemoveSouls_reflection_ = NULL;
const ::google::protobuf::Descriptor* proSoulRes_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  proSoulRes_reflection_ = NULL;
const ::google::protobuf::Descriptor* proSoulsRes_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  proSoulsRes_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_soul_2eproto() {
  protobuf_AddDesc_soul_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "soul.proto");
  GOOGLE_CHECK(file != NULL);
  proSoul_descriptor_ = file->message_type(0);
  static const int proSoul_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proSoul, soul_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proSoul, num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proSoul, protect_ts_),
  };
  proSoul_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      proSoul_descriptor_,
      proSoul::default_instance_,
      proSoul_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proSoul, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proSoul, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(proSoul));
  proGetSoul_descriptor_ = file->message_type(1);
  static const int proGetSoul_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proGetSoul, user_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proGetSoul, soul_id_),
  };
  proGetSoul_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      proGetSoul_descriptor_,
      proGetSoul::default_instance_,
      proGetSoul_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proGetSoul, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proGetSoul, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(proGetSoul));
  proGetSouls_descriptor_ = file->message_type(2);
  static const int proGetSouls_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proGetSouls, user_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proGetSouls, souls_),
  };
  proGetSouls_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      proGetSouls_descriptor_,
      proGetSouls::default_instance_,
      proGetSouls_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proGetSouls, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proGetSouls, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(proGetSouls));
  proAddSoul_descriptor_ = file->message_type(3);
  static const int proAddSoul_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proAddSoul, user_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proAddSoul, soul_),
  };
  proAddSoul_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      proAddSoul_descriptor_,
      proAddSoul::default_instance_,
      proAddSoul_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proAddSoul, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proAddSoul, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(proAddSoul));
  proAddSouls_descriptor_ = file->message_type(4);
  static const int proAddSouls_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proAddSouls, user_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proAddSouls, souls_),
  };
  proAddSouls_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      proAddSouls_descriptor_,
      proAddSouls::default_instance_,
      proAddSouls_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proAddSouls, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proAddSouls, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(proAddSouls));
  proRemoveSoul_descriptor_ = file->message_type(5);
  static const int proRemoveSoul_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proRemoveSoul, user_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proRemoveSoul, soul_),
  };
  proRemoveSoul_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      proRemoveSoul_descriptor_,
      proRemoveSoul::default_instance_,
      proRemoveSoul_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proRemoveSoul, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proRemoveSoul, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(proRemoveSoul));
  proRemoveSouls_descriptor_ = file->message_type(6);
  static const int proRemoveSouls_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proRemoveSouls, user_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proRemoveSouls, souls_),
  };
  proRemoveSouls_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      proRemoveSouls_descriptor_,
      proRemoveSouls::default_instance_,
      proRemoveSouls_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proRemoveSouls, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proRemoveSouls, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(proRemoveSouls));
  proSoulRes_descriptor_ = file->message_type(7);
  static const int proSoulRes_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proSoulRes, code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proSoulRes, soul_),
  };
  proSoulRes_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      proSoulRes_descriptor_,
      proSoulRes::default_instance_,
      proSoulRes_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proSoulRes, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proSoulRes, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(proSoulRes));
  proSoulsRes_descriptor_ = file->message_type(8);
  static const int proSoulsRes_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proSoulsRes, code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proSoulsRes, souls_),
  };
  proSoulsRes_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      proSoulsRes_descriptor_,
      proSoulsRes::default_instance_,
      proSoulsRes_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proSoulsRes, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(proSoulsRes, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(proSoulsRes));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_soul_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    proSoul_descriptor_, &proSoul::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    proGetSoul_descriptor_, &proGetSoul::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    proGetSouls_descriptor_, &proGetSouls::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    proAddSoul_descriptor_, &proAddSoul::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    proAddSouls_descriptor_, &proAddSouls::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    proRemoveSoul_descriptor_, &proRemoveSoul::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    proRemoveSouls_descriptor_, &proRemoveSouls::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    proSoulRes_descriptor_, &proSoulRes::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    proSoulsRes_descriptor_, &proSoulsRes::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_soul_2eproto() {
  delete proSoul::default_instance_;
  delete proSoul_reflection_;
  delete proGetSoul::default_instance_;
  delete proGetSoul_reflection_;
  delete proGetSouls::default_instance_;
  delete proGetSouls_reflection_;
  delete proAddSoul::default_instance_;
  delete proAddSoul_reflection_;
  delete proAddSouls::default_instance_;
  delete proAddSouls_reflection_;
  delete proRemoveSoul::default_instance_;
  delete proRemoveSoul_reflection_;
  delete proRemoveSouls::default_instance_;
  delete proRemoveSouls_reflection_;
  delete proSoulRes::default_instance_;
  delete proSoulRes_reflection_;
  delete proSoulsRes::default_instance_;
  delete proSoulsRes_reflection_;
}

void protobuf_AddDesc_soul_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\nsoul.proto\022\005cache\";\n\007proSoul\022\017\n\007soul_i"
    "d\030\001 \002(\r\022\013\n\003num\030\002 \002(\r\022\022\n\nprotect_ts\030\003 \002(\r"
    "\".\n\nproGetSoul\022\017\n\007user_id\030\001 \002(\r\022\017\n\007soul_"
    "id\030\002 \002(\r\"-\n\013proGetSouls\022\017\n\007user_id\030\001 \002(\r"
    "\022\r\n\005souls\030\002 \003(\r\";\n\nproAddSoul\022\017\n\007user_id"
    "\030\001 \002(\r\022\034\n\004soul\030\002 \002(\0132\016.cache.proSoul\"=\n\013"
    "proAddSouls\022\017\n\007user_id\030\001 \002(\r\022\035\n\005souls\030\002 "
    "\003(\0132\016.cache.proSoul\">\n\rproRemoveSoul\022\017\n\007"
    "user_id\030\001 \002(\r\022\034\n\004soul\030\002 \002(\0132\016.cache.proS"
    "oul\"@\n\016proRemoveSouls\022\017\n\007user_id\030\001 \002(\r\022\035"
    "\n\005souls\030\002 \003(\0132\016.cache.proSoul\"8\n\nproSoul"
    "Res\022\014\n\004code\030\001 \002(\r\022\034\n\004soul\030\002 \001(\0132\016.cache."
    "proSoul\":\n\013proSoulsRes\022\014\n\004code\030\001 \002(\r\022\035\n\005"
    "souls\030\002 \003(\0132\016.cache.proSoul", 547);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "soul.proto", &protobuf_RegisterTypes);
  proSoul::default_instance_ = new proSoul();
  proGetSoul::default_instance_ = new proGetSoul();
  proGetSouls::default_instance_ = new proGetSouls();
  proAddSoul::default_instance_ = new proAddSoul();
  proAddSouls::default_instance_ = new proAddSouls();
  proRemoveSoul::default_instance_ = new proRemoveSoul();
  proRemoveSouls::default_instance_ = new proRemoveSouls();
  proSoulRes::default_instance_ = new proSoulRes();
  proSoulsRes::default_instance_ = new proSoulsRes();
  proSoul::default_instance_->InitAsDefaultInstance();
  proGetSoul::default_instance_->InitAsDefaultInstance();
  proGetSouls::default_instance_->InitAsDefaultInstance();
  proAddSoul::default_instance_->InitAsDefaultInstance();
  proAddSouls::default_instance_->InitAsDefaultInstance();
  proRemoveSoul::default_instance_->InitAsDefaultInstance();
  proRemoveSouls::default_instance_->InitAsDefaultInstance();
  proSoulRes::default_instance_->InitAsDefaultInstance();
  proSoulsRes::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_soul_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_soul_2eproto {
  StaticDescriptorInitializer_soul_2eproto() {
    protobuf_AddDesc_soul_2eproto();
  }
} static_descriptor_initializer_soul_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int proSoul::kSoulIdFieldNumber;
const int proSoul::kNumFieldNumber;
const int proSoul::kProtectTsFieldNumber;
#endif  // !_MSC_VER

proSoul::proSoul()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void proSoul::InitAsDefaultInstance() {
}

proSoul::proSoul(const proSoul& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void proSoul::SharedCtor() {
  _cached_size_ = 0;
  soul_id_ = 0u;
  num_ = 0u;
  protect_ts_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

proSoul::~proSoul() {
  SharedDtor();
}

void proSoul::SharedDtor() {
  if (this != default_instance_) {
  }
}

void proSoul::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* proSoul::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return proSoul_descriptor_;
}

const proSoul& proSoul::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_soul_2eproto();
  return *default_instance_;
}

proSoul* proSoul::default_instance_ = NULL;

proSoul* proSoul::New() const {
  return new proSoul;
}

void proSoul::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    soul_id_ = 0u;
    num_ = 0u;
    protect_ts_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool proSoul::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 soul_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &soul_id_)));
          set_has_soul_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_num;
        break;
      }

      // required uint32 num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_protect_ts;
        break;
      }

      // required uint32 protect_ts = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_protect_ts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &protect_ts_)));
          set_has_protect_ts();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void proSoul::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 soul_id = 1;
  if (has_soul_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->soul_id(), output);
  }

  // required uint32 num = 2;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->num(), output);
  }

  // required uint32 protect_ts = 3;
  if (has_protect_ts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->protect_ts(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* proSoul::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 soul_id = 1;
  if (has_soul_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->soul_id(), target);
  }

  // required uint32 num = 2;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->num(), target);
  }

  // required uint32 protect_ts = 3;
  if (has_protect_ts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->protect_ts(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int proSoul::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 soul_id = 1;
    if (has_soul_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->soul_id());
    }

    // required uint32 num = 2;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num());
    }

    // required uint32 protect_ts = 3;
    if (has_protect_ts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->protect_ts());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void proSoul::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const proSoul* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const proSoul*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void proSoul::MergeFrom(const proSoul& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_soul_id()) {
      set_soul_id(from.soul_id());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_protect_ts()) {
      set_protect_ts(from.protect_ts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void proSoul::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void proSoul::CopyFrom(const proSoul& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proSoul::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void proSoul::Swap(proSoul* other) {
  if (other != this) {
    std::swap(soul_id_, other->soul_id_);
    std::swap(num_, other->num_);
    std::swap(protect_ts_, other->protect_ts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata proSoul::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = proSoul_descriptor_;
  metadata.reflection = proSoul_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int proGetSoul::kUserIdFieldNumber;
const int proGetSoul::kSoulIdFieldNumber;
#endif  // !_MSC_VER

proGetSoul::proGetSoul()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void proGetSoul::InitAsDefaultInstance() {
}

proGetSoul::proGetSoul(const proGetSoul& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void proGetSoul::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  soul_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

proGetSoul::~proGetSoul() {
  SharedDtor();
}

void proGetSoul::SharedDtor() {
  if (this != default_instance_) {
  }
}

void proGetSoul::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* proGetSoul::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return proGetSoul_descriptor_;
}

const proGetSoul& proGetSoul::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_soul_2eproto();
  return *default_instance_;
}

proGetSoul* proGetSoul::default_instance_ = NULL;

proGetSoul* proGetSoul::New() const {
  return new proGetSoul;
}

void proGetSoul::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = 0u;
    soul_id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool proGetSoul::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_soul_id;
        break;
      }

      // required uint32 soul_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_soul_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &soul_id_)));
          set_has_soul_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void proGetSoul::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 soul_id = 2;
  if (has_soul_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->soul_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* proGetSoul::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->user_id(), target);
  }

  // required uint32 soul_id = 2;
  if (has_soul_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->soul_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int proGetSoul::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 soul_id = 2;
    if (has_soul_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->soul_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void proGetSoul::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const proGetSoul* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const proGetSoul*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void proGetSoul::MergeFrom(const proGetSoul& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_soul_id()) {
      set_soul_id(from.soul_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void proGetSoul::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void proGetSoul::CopyFrom(const proGetSoul& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proGetSoul::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void proGetSoul::Swap(proGetSoul* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(soul_id_, other->soul_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata proGetSoul::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = proGetSoul_descriptor_;
  metadata.reflection = proGetSoul_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int proGetSouls::kUserIdFieldNumber;
const int proGetSouls::kSoulsFieldNumber;
#endif  // !_MSC_VER

proGetSouls::proGetSouls()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void proGetSouls::InitAsDefaultInstance() {
}

proGetSouls::proGetSouls(const proGetSouls& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void proGetSouls::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

proGetSouls::~proGetSouls() {
  SharedDtor();
}

void proGetSouls::SharedDtor() {
  if (this != default_instance_) {
  }
}

void proGetSouls::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* proGetSouls::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return proGetSouls_descriptor_;
}

const proGetSouls& proGetSouls::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_soul_2eproto();
  return *default_instance_;
}

proGetSouls* proGetSouls::default_instance_ = NULL;

proGetSouls* proGetSouls::New() const {
  return new proGetSouls;
}

void proGetSouls::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = 0u;
  }
  souls_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool proGetSouls::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_souls;
        break;
      }

      // repeated uint32 souls = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_souls:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_souls())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_souls())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_souls;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void proGetSouls::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // repeated uint32 souls = 2;
  for (int i = 0; i < this->souls_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->souls(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* proGetSouls::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->user_id(), target);
  }

  // repeated uint32 souls = 2;
  for (int i = 0; i < this->souls_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->souls(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int proGetSouls::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

  }
  // repeated uint32 souls = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->souls_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->souls(i));
    }
    total_size += 1 * this->souls_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void proGetSouls::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const proGetSouls* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const proGetSouls*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void proGetSouls::MergeFrom(const proGetSouls& from) {
  GOOGLE_CHECK_NE(&from, this);
  souls_.MergeFrom(from.souls_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void proGetSouls::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void proGetSouls::CopyFrom(const proGetSouls& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proGetSouls::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void proGetSouls::Swap(proGetSouls* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    souls_.Swap(&other->souls_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata proGetSouls::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = proGetSouls_descriptor_;
  metadata.reflection = proGetSouls_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int proAddSoul::kUserIdFieldNumber;
const int proAddSoul::kSoulFieldNumber;
#endif  // !_MSC_VER

proAddSoul::proAddSoul()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void proAddSoul::InitAsDefaultInstance() {
  soul_ = const_cast< ::cache::proSoul*>(&::cache::proSoul::default_instance());
}

proAddSoul::proAddSoul(const proAddSoul& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void proAddSoul::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  soul_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

proAddSoul::~proAddSoul() {
  SharedDtor();
}

void proAddSoul::SharedDtor() {
  if (this != default_instance_) {
    delete soul_;
  }
}

void proAddSoul::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* proAddSoul::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return proAddSoul_descriptor_;
}

const proAddSoul& proAddSoul::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_soul_2eproto();
  return *default_instance_;
}

proAddSoul* proAddSoul::default_instance_ = NULL;

proAddSoul* proAddSoul::New() const {
  return new proAddSoul;
}

void proAddSoul::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = 0u;
    if (has_soul()) {
      if (soul_ != NULL) soul_->::cache::proSoul::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool proAddSoul::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_soul;
        break;
      }

      // required .cache.proSoul soul = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_soul:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_soul()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void proAddSoul::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required .cache.proSoul soul = 2;
  if (has_soul()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->soul(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* proAddSoul::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->user_id(), target);
  }

  // required .cache.proSoul soul = 2;
  if (has_soul()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->soul(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int proAddSoul::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required .cache.proSoul soul = 2;
    if (has_soul()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->soul());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void proAddSoul::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const proAddSoul* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const proAddSoul*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void proAddSoul::MergeFrom(const proAddSoul& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_soul()) {
      mutable_soul()->::cache::proSoul::MergeFrom(from.soul());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void proAddSoul::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void proAddSoul::CopyFrom(const proAddSoul& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proAddSoul::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_soul()) {
    if (!this->soul().IsInitialized()) return false;
  }
  return true;
}

void proAddSoul::Swap(proAddSoul* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(soul_, other->soul_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata proAddSoul::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = proAddSoul_descriptor_;
  metadata.reflection = proAddSoul_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int proAddSouls::kUserIdFieldNumber;
const int proAddSouls::kSoulsFieldNumber;
#endif  // !_MSC_VER

proAddSouls::proAddSouls()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void proAddSouls::InitAsDefaultInstance() {
}

proAddSouls::proAddSouls(const proAddSouls& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void proAddSouls::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

proAddSouls::~proAddSouls() {
  SharedDtor();
}

void proAddSouls::SharedDtor() {
  if (this != default_instance_) {
  }
}

void proAddSouls::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* proAddSouls::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return proAddSouls_descriptor_;
}

const proAddSouls& proAddSouls::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_soul_2eproto();
  return *default_instance_;
}

proAddSouls* proAddSouls::default_instance_ = NULL;

proAddSouls* proAddSouls::New() const {
  return new proAddSouls;
}

void proAddSouls::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = 0u;
  }
  souls_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool proAddSouls::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_souls;
        break;
      }

      // repeated .cache.proSoul souls = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_souls:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_souls()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_souls;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void proAddSouls::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // repeated .cache.proSoul souls = 2;
  for (int i = 0; i < this->souls_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->souls(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* proAddSouls::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->user_id(), target);
  }

  // repeated .cache.proSoul souls = 2;
  for (int i = 0; i < this->souls_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->souls(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int proAddSouls::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

  }
  // repeated .cache.proSoul souls = 2;
  total_size += 1 * this->souls_size();
  for (int i = 0; i < this->souls_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->souls(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void proAddSouls::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const proAddSouls* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const proAddSouls*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void proAddSouls::MergeFrom(const proAddSouls& from) {
  GOOGLE_CHECK_NE(&from, this);
  souls_.MergeFrom(from.souls_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void proAddSouls::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void proAddSouls::CopyFrom(const proAddSouls& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proAddSouls::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < souls_size(); i++) {
    if (!this->souls(i).IsInitialized()) return false;
  }
  return true;
}

void proAddSouls::Swap(proAddSouls* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    souls_.Swap(&other->souls_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata proAddSouls::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = proAddSouls_descriptor_;
  metadata.reflection = proAddSouls_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int proRemoveSoul::kUserIdFieldNumber;
const int proRemoveSoul::kSoulFieldNumber;
#endif  // !_MSC_VER

proRemoveSoul::proRemoveSoul()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void proRemoveSoul::InitAsDefaultInstance() {
  soul_ = const_cast< ::cache::proSoul*>(&::cache::proSoul::default_instance());
}

proRemoveSoul::proRemoveSoul(const proRemoveSoul& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void proRemoveSoul::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  soul_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

proRemoveSoul::~proRemoveSoul() {
  SharedDtor();
}

void proRemoveSoul::SharedDtor() {
  if (this != default_instance_) {
    delete soul_;
  }
}

void proRemoveSoul::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* proRemoveSoul::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return proRemoveSoul_descriptor_;
}

const proRemoveSoul& proRemoveSoul::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_soul_2eproto();
  return *default_instance_;
}

proRemoveSoul* proRemoveSoul::default_instance_ = NULL;

proRemoveSoul* proRemoveSoul::New() const {
  return new proRemoveSoul;
}

void proRemoveSoul::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = 0u;
    if (has_soul()) {
      if (soul_ != NULL) soul_->::cache::proSoul::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool proRemoveSoul::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_soul;
        break;
      }

      // required .cache.proSoul soul = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_soul:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_soul()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void proRemoveSoul::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required .cache.proSoul soul = 2;
  if (has_soul()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->soul(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* proRemoveSoul::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->user_id(), target);
  }

  // required .cache.proSoul soul = 2;
  if (has_soul()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->soul(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int proRemoveSoul::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required .cache.proSoul soul = 2;
    if (has_soul()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->soul());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void proRemoveSoul::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const proRemoveSoul* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const proRemoveSoul*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void proRemoveSoul::MergeFrom(const proRemoveSoul& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_soul()) {
      mutable_soul()->::cache::proSoul::MergeFrom(from.soul());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void proRemoveSoul::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void proRemoveSoul::CopyFrom(const proRemoveSoul& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proRemoveSoul::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_soul()) {
    if (!this->soul().IsInitialized()) return false;
  }
  return true;
}

void proRemoveSoul::Swap(proRemoveSoul* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(soul_, other->soul_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata proRemoveSoul::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = proRemoveSoul_descriptor_;
  metadata.reflection = proRemoveSoul_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int proRemoveSouls::kUserIdFieldNumber;
const int proRemoveSouls::kSoulsFieldNumber;
#endif  // !_MSC_VER

proRemoveSouls::proRemoveSouls()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void proRemoveSouls::InitAsDefaultInstance() {
}

proRemoveSouls::proRemoveSouls(const proRemoveSouls& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void proRemoveSouls::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

proRemoveSouls::~proRemoveSouls() {
  SharedDtor();
}

void proRemoveSouls::SharedDtor() {
  if (this != default_instance_) {
  }
}

void proRemoveSouls::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* proRemoveSouls::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return proRemoveSouls_descriptor_;
}

const proRemoveSouls& proRemoveSouls::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_soul_2eproto();
  return *default_instance_;
}

proRemoveSouls* proRemoveSouls::default_instance_ = NULL;

proRemoveSouls* proRemoveSouls::New() const {
  return new proRemoveSouls;
}

void proRemoveSouls::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    user_id_ = 0u;
  }
  souls_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool proRemoveSouls::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_souls;
        break;
      }

      // repeated .cache.proSoul souls = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_souls:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_souls()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_souls;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void proRemoveSouls::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // repeated .cache.proSoul souls = 2;
  for (int i = 0; i < this->souls_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->souls(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* proRemoveSouls::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 user_id = 1;
  if (has_user_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->user_id(), target);
  }

  // repeated .cache.proSoul souls = 2;
  for (int i = 0; i < this->souls_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->souls(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int proRemoveSouls::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

  }
  // repeated .cache.proSoul souls = 2;
  total_size += 1 * this->souls_size();
  for (int i = 0; i < this->souls_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->souls(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void proRemoveSouls::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const proRemoveSouls* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const proRemoveSouls*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void proRemoveSouls::MergeFrom(const proRemoveSouls& from) {
  GOOGLE_CHECK_NE(&from, this);
  souls_.MergeFrom(from.souls_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void proRemoveSouls::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void proRemoveSouls::CopyFrom(const proRemoveSouls& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proRemoveSouls::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < souls_size(); i++) {
    if (!this->souls(i).IsInitialized()) return false;
  }
  return true;
}

void proRemoveSouls::Swap(proRemoveSouls* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    souls_.Swap(&other->souls_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata proRemoveSouls::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = proRemoveSouls_descriptor_;
  metadata.reflection = proRemoveSouls_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int proSoulRes::kCodeFieldNumber;
const int proSoulRes::kSoulFieldNumber;
#endif  // !_MSC_VER

proSoulRes::proSoulRes()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void proSoulRes::InitAsDefaultInstance() {
  soul_ = const_cast< ::cache::proSoul*>(&::cache::proSoul::default_instance());
}

proSoulRes::proSoulRes(const proSoulRes& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void proSoulRes::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0u;
  soul_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

proSoulRes::~proSoulRes() {
  SharedDtor();
}

void proSoulRes::SharedDtor() {
  if (this != default_instance_) {
    delete soul_;
  }
}

void proSoulRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* proSoulRes::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return proSoulRes_descriptor_;
}

const proSoulRes& proSoulRes::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_soul_2eproto();
  return *default_instance_;
}

proSoulRes* proSoulRes::default_instance_ = NULL;

proSoulRes* proSoulRes::New() const {
  return new proSoulRes;
}

void proSoulRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0u;
    if (has_soul()) {
      if (soul_ != NULL) soul_->::cache::proSoul::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool proSoulRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_soul;
        break;
      }

      // optional .cache.proSoul soul = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_soul:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_soul()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void proSoulRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->code(), output);
  }

  // optional .cache.proSoul soul = 2;
  if (has_soul()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->soul(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* proSoulRes::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 code = 1;
  if (has_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->code(), target);
  }

  // optional .cache.proSoul soul = 2;
  if (has_soul()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->soul(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int proSoulRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->code());
    }

    // optional .cache.proSoul soul = 2;
    if (has_soul()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->soul());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void proSoulRes::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const proSoulRes* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const proSoulRes*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void proSoulRes::MergeFrom(const proSoulRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_soul()) {
      mutable_soul()->::cache::proSoul::MergeFrom(from.soul());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void proSoulRes::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void proSoulRes::CopyFrom(const proSoulRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proSoulRes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_soul()) {
    if (!this->soul().IsInitialized()) return false;
  }
  return true;
}

void proSoulRes::Swap(proSoulRes* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(soul_, other->soul_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata proSoulRes::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = proSoulRes_descriptor_;
  metadata.reflection = proSoulRes_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int proSoulsRes::kCodeFieldNumber;
const int proSoulsRes::kSoulsFieldNumber;
#endif  // !_MSC_VER

proSoulsRes::proSoulsRes()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void proSoulsRes::InitAsDefaultInstance() {
}

proSoulsRes::proSoulsRes(const proSoulsRes& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void proSoulsRes::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

proSoulsRes::~proSoulsRes() {
  SharedDtor();
}

void proSoulsRes::SharedDtor() {
  if (this != default_instance_) {
  }
}

void proSoulsRes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* proSoulsRes::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return proSoulsRes_descriptor_;
}

const proSoulsRes& proSoulsRes::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_soul_2eproto();
  return *default_instance_;
}

proSoulsRes* proSoulsRes::default_instance_ = NULL;

proSoulsRes* proSoulsRes::New() const {
  return new proSoulsRes;
}

void proSoulsRes::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0u;
  }
  souls_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool proSoulsRes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_souls;
        break;
      }

      // repeated .cache.proSoul souls = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_souls:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_souls()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_souls;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void proSoulsRes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->code(), output);
  }

  // repeated .cache.proSoul souls = 2;
  for (int i = 0; i < this->souls_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->souls(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* proSoulsRes::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 code = 1;
  if (has_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->code(), target);
  }

  // repeated .cache.proSoul souls = 2;
  for (int i = 0; i < this->souls_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->souls(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int proSoulsRes::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->code());
    }

  }
  // repeated .cache.proSoul souls = 2;
  total_size += 1 * this->souls_size();
  for (int i = 0; i < this->souls_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->souls(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void proSoulsRes::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const proSoulsRes* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const proSoulsRes*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void proSoulsRes::MergeFrom(const proSoulsRes& from) {
  GOOGLE_CHECK_NE(&from, this);
  souls_.MergeFrom(from.souls_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void proSoulsRes::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void proSoulsRes::CopyFrom(const proSoulsRes& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool proSoulsRes::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < souls_size(); i++) {
    if (!this->souls(i).IsInitialized()) return false;
  }
  return true;
}

void proSoulsRes::Swap(proSoulsRes* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    souls_.Swap(&other->souls_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata proSoulsRes::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = proSoulsRes_descriptor_;
  metadata.reflection = proSoulsRes_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cache

// @@protoc_insertion_point(global_scope)
