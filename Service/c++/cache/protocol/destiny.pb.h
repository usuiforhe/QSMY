// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: destiny.proto

#ifndef PROTOBUF_destiny_2eproto__INCLUDED
#define PROTOBUF_destiny_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace cache {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_destiny_2eproto();
void protobuf_AssignDesc_destiny_2eproto();
void protobuf_ShutdownFile_destiny_2eproto();

class proDestiny;
class proGetDestiny;
class proGetDestinies;
class proSaveDestiny;
class proDestinySoul;
class proImproveDestiny;
class proDestinyRes;
class proDestiniesRes;

// ===================================================================

class proDestiny : public ::google::protobuf::Message {
 public:
  proDestiny();
  virtual ~proDestiny();

  proDestiny(const proDestiny& from);

  inline proDestiny& operator=(const proDestiny& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const proDestiny& default_instance();

  void Swap(proDestiny* other);

  // implements Message ----------------------------------------------

  proDestiny* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const proDestiny& from);
  void MergeFrom(const proDestiny& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 destiny_id = 1;
  inline bool has_destiny_id() const;
  inline void clear_destiny_id();
  static const int kDestinyIdFieldNumber = 1;
  inline ::google::protobuf::uint32 destiny_id() const;
  inline void set_destiny_id(::google::protobuf::uint32 value);

  // required uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 reward_ts = 4;
  inline bool has_reward_ts() const;
  inline void clear_reward_ts();
  static const int kRewardTsFieldNumber = 4;
  inline ::google::protobuf::uint32 reward_ts() const;
  inline void set_reward_ts(::google::protobuf::uint32 value);

  // required uint32 num1 = 5;
  inline bool has_num1() const;
  inline void clear_num1();
  static const int kNum1FieldNumber = 5;
  inline ::google::protobuf::uint32 num1() const;
  inline void set_num1(::google::protobuf::uint32 value);

  // optional uint32 num2 = 6;
  inline bool has_num2() const;
  inline void clear_num2();
  static const int kNum2FieldNumber = 6;
  inline ::google::protobuf::uint32 num2() const;
  inline void set_num2(::google::protobuf::uint32 value);

  // optional uint32 num3 = 7;
  inline bool has_num3() const;
  inline void clear_num3();
  static const int kNum3FieldNumber = 7;
  inline ::google::protobuf::uint32 num3() const;
  inline void set_num3(::google::protobuf::uint32 value);

  // optional uint32 num4 = 8;
  inline bool has_num4() const;
  inline void clear_num4();
  static const int kNum4FieldNumber = 8;
  inline ::google::protobuf::uint32 num4() const;
  inline void set_num4(::google::protobuf::uint32 value);

  // optional uint32 num5 = 9;
  inline bool has_num5() const;
  inline void clear_num5();
  static const int kNum5FieldNumber = 9;
  inline ::google::protobuf::uint32 num5() const;
  inline void set_num5(::google::protobuf::uint32 value);

  // optional uint32 num6 = 10;
  inline bool has_num6() const;
  inline void clear_num6();
  static const int kNum6FieldNumber = 10;
  inline ::google::protobuf::uint32 num6() const;
  inline void set_num6(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cache.proDestiny)
 private:
  inline void set_has_destiny_id();
  inline void clear_has_destiny_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_reward_ts();
  inline void clear_has_reward_ts();
  inline void set_has_num1();
  inline void clear_has_num1();
  inline void set_has_num2();
  inline void clear_has_num2();
  inline void set_has_num3();
  inline void clear_has_num3();
  inline void set_has_num4();
  inline void clear_has_num4();
  inline void set_has_num5();
  inline void clear_has_num5();
  inline void set_has_num6();
  inline void clear_has_num6();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 destiny_id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 reward_ts_;
  ::google::protobuf::uint32 num1_;
  ::google::protobuf::uint32 num2_;
  ::google::protobuf::uint32 num3_;
  ::google::protobuf::uint32 num4_;
  ::google::protobuf::uint32 num5_;
  ::google::protobuf::uint32 num6_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_destiny_2eproto();
  friend void protobuf_AssignDesc_destiny_2eproto();
  friend void protobuf_ShutdownFile_destiny_2eproto();

  void InitAsDefaultInstance();
  static proDestiny* default_instance_;
};
// -------------------------------------------------------------------

class proGetDestiny : public ::google::protobuf::Message {
 public:
  proGetDestiny();
  virtual ~proGetDestiny();

  proGetDestiny(const proGetDestiny& from);

  inline proGetDestiny& operator=(const proGetDestiny& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const proGetDestiny& default_instance();

  void Swap(proGetDestiny* other);

  // implements Message ----------------------------------------------

  proGetDestiny* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const proGetDestiny& from);
  void MergeFrom(const proGetDestiny& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 destiny_id = 2;
  inline bool has_destiny_id() const;
  inline void clear_destiny_id();
  static const int kDestinyIdFieldNumber = 2;
  inline ::google::protobuf::uint32 destiny_id() const;
  inline void set_destiny_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cache.proGetDestiny)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_destiny_id();
  inline void clear_has_destiny_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 destiny_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_destiny_2eproto();
  friend void protobuf_AssignDesc_destiny_2eproto();
  friend void protobuf_ShutdownFile_destiny_2eproto();

  void InitAsDefaultInstance();
  static proGetDestiny* default_instance_;
};
// -------------------------------------------------------------------

class proGetDestinies : public ::google::protobuf::Message {
 public:
  proGetDestinies();
  virtual ~proGetDestinies();

  proGetDestinies(const proGetDestinies& from);

  inline proGetDestinies& operator=(const proGetDestinies& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const proGetDestinies& default_instance();

  void Swap(proGetDestinies* other);

  // implements Message ----------------------------------------------

  proGetDestinies* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const proGetDestinies& from);
  void MergeFrom(const proGetDestinies& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cache.proGetDestinies)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_destiny_2eproto();
  friend void protobuf_AssignDesc_destiny_2eproto();
  friend void protobuf_ShutdownFile_destiny_2eproto();

  void InitAsDefaultInstance();
  static proGetDestinies* default_instance_;
};
// -------------------------------------------------------------------

class proSaveDestiny : public ::google::protobuf::Message {
 public:
  proSaveDestiny();
  virtual ~proSaveDestiny();

  proSaveDestiny(const proSaveDestiny& from);

  inline proSaveDestiny& operator=(const proSaveDestiny& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const proSaveDestiny& default_instance();

  void Swap(proSaveDestiny* other);

  // implements Message ----------------------------------------------

  proSaveDestiny* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const proSaveDestiny& from);
  void MergeFrom(const proSaveDestiny& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .cache.proDestiny destiny = 2;
  inline bool has_destiny() const;
  inline void clear_destiny();
  static const int kDestinyFieldNumber = 2;
  inline const ::cache::proDestiny& destiny() const;
  inline ::cache::proDestiny* mutable_destiny();
  inline ::cache::proDestiny* release_destiny();
  inline void set_allocated_destiny(::cache::proDestiny* destiny);

  // @@protoc_insertion_point(class_scope:cache.proSaveDestiny)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_destiny();
  inline void clear_has_destiny();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::cache::proDestiny* destiny_;
  ::google::protobuf::uint32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_destiny_2eproto();
  friend void protobuf_AssignDesc_destiny_2eproto();
  friend void protobuf_ShutdownFile_destiny_2eproto();

  void InitAsDefaultInstance();
  static proSaveDestiny* default_instance_;
};
// -------------------------------------------------------------------

class proDestinySoul : public ::google::protobuf::Message {
 public:
  proDestinySoul();
  virtual ~proDestinySoul();

  proDestinySoul(const proDestinySoul& from);

  inline proDestinySoul& operator=(const proDestinySoul& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const proDestinySoul& default_instance();

  void Swap(proDestinySoul* other);

  // implements Message ----------------------------------------------

  proDestinySoul* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const proDestinySoul& from);
  void MergeFrom(const proDestinySoul& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 soul_id = 1;
  inline bool has_soul_id() const;
  inline void clear_soul_id();
  static const int kSoulIdFieldNumber = 1;
  inline ::google::protobuf::uint32 soul_id() const;
  inline void set_soul_id(::google::protobuf::uint32 value);

  // required uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cache.proDestinySoul)
 private:
  inline void set_has_soul_id();
  inline void clear_has_soul_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 soul_id_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_destiny_2eproto();
  friend void protobuf_AssignDesc_destiny_2eproto();
  friend void protobuf_ShutdownFile_destiny_2eproto();

  void InitAsDefaultInstance();
  static proDestinySoul* default_instance_;
};
// -------------------------------------------------------------------

class proImproveDestiny : public ::google::protobuf::Message {
 public:
  proImproveDestiny();
  virtual ~proImproveDestiny();

  proImproveDestiny(const proImproveDestiny& from);

  inline proImproveDestiny& operator=(const proImproveDestiny& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const proImproveDestiny& default_instance();

  void Swap(proImproveDestiny* other);

  // implements Message ----------------------------------------------

  proImproveDestiny* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const proImproveDestiny& from);
  void MergeFrom(const proImproveDestiny& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // repeated .cache.proDestinySoul consume_souls = 2;
  inline int consume_souls_size() const;
  inline void clear_consume_souls();
  static const int kConsumeSoulsFieldNumber = 2;
  inline const ::cache::proDestinySoul& consume_souls(int index) const;
  inline ::cache::proDestinySoul* mutable_consume_souls(int index);
  inline ::cache::proDestinySoul* add_consume_souls();
  inline const ::google::protobuf::RepeatedPtrField< ::cache::proDestinySoul >&
      consume_souls() const;
  inline ::google::protobuf::RepeatedPtrField< ::cache::proDestinySoul >*
      mutable_consume_souls();

  // required .cache.proDestiny destiny = 3;
  inline bool has_destiny() const;
  inline void clear_destiny();
  static const int kDestinyFieldNumber = 3;
  inline const ::cache::proDestiny& destiny() const;
  inline ::cache::proDestiny* mutable_destiny();
  inline ::cache::proDestiny* release_destiny();
  inline void set_allocated_destiny(::cache::proDestiny* destiny);

  // @@protoc_insertion_point(class_scope:cache.proImproveDestiny)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_destiny();
  inline void clear_has_destiny();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::cache::proDestinySoul > consume_souls_;
  ::cache::proDestiny* destiny_;
  ::google::protobuf::uint32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_destiny_2eproto();
  friend void protobuf_AssignDesc_destiny_2eproto();
  friend void protobuf_ShutdownFile_destiny_2eproto();

  void InitAsDefaultInstance();
  static proImproveDestiny* default_instance_;
};
// -------------------------------------------------------------------

class proDestinyRes : public ::google::protobuf::Message {
 public:
  proDestinyRes();
  virtual ~proDestinyRes();

  proDestinyRes(const proDestinyRes& from);

  inline proDestinyRes& operator=(const proDestinyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const proDestinyRes& default_instance();

  void Swap(proDestinyRes* other);

  // implements Message ----------------------------------------------

  proDestinyRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const proDestinyRes& from);
  void MergeFrom(const proDestinyRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 code() const;
  inline void set_code(::google::protobuf::uint32 value);

  // optional .cache.proDestiny destiny = 2;
  inline bool has_destiny() const;
  inline void clear_destiny();
  static const int kDestinyFieldNumber = 2;
  inline const ::cache::proDestiny& destiny() const;
  inline ::cache::proDestiny* mutable_destiny();
  inline ::cache::proDestiny* release_destiny();
  inline void set_allocated_destiny(::cache::proDestiny* destiny);

  // @@protoc_insertion_point(class_scope:cache.proDestinyRes)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_destiny();
  inline void clear_has_destiny();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::cache::proDestiny* destiny_;
  ::google::protobuf::uint32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_destiny_2eproto();
  friend void protobuf_AssignDesc_destiny_2eproto();
  friend void protobuf_ShutdownFile_destiny_2eproto();

  void InitAsDefaultInstance();
  static proDestinyRes* default_instance_;
};
// -------------------------------------------------------------------

class proDestiniesRes : public ::google::protobuf::Message {
 public:
  proDestiniesRes();
  virtual ~proDestiniesRes();

  proDestiniesRes(const proDestiniesRes& from);

  inline proDestiniesRes& operator=(const proDestiniesRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const proDestiniesRes& default_instance();

  void Swap(proDestiniesRes* other);

  // implements Message ----------------------------------------------

  proDestiniesRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const proDestiniesRes& from);
  void MergeFrom(const proDestiniesRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 code() const;
  inline void set_code(::google::protobuf::uint32 value);

  // repeated .cache.proDestiny destinies = 2;
  inline int destinies_size() const;
  inline void clear_destinies();
  static const int kDestiniesFieldNumber = 2;
  inline const ::cache::proDestiny& destinies(int index) const;
  inline ::cache::proDestiny* mutable_destinies(int index);
  inline ::cache::proDestiny* add_destinies();
  inline const ::google::protobuf::RepeatedPtrField< ::cache::proDestiny >&
      destinies() const;
  inline ::google::protobuf::RepeatedPtrField< ::cache::proDestiny >*
      mutable_destinies();

  // @@protoc_insertion_point(class_scope:cache.proDestiniesRes)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::cache::proDestiny > destinies_;
  ::google::protobuf::uint32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_destiny_2eproto();
  friend void protobuf_AssignDesc_destiny_2eproto();
  friend void protobuf_ShutdownFile_destiny_2eproto();

  void InitAsDefaultInstance();
  static proDestiniesRes* default_instance_;
};
// ===================================================================


// ===================================================================

// proDestiny

// required uint32 destiny_id = 1;
inline bool proDestiny::has_destiny_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void proDestiny::set_has_destiny_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void proDestiny::clear_has_destiny_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void proDestiny::clear_destiny_id() {
  destiny_id_ = 0u;
  clear_has_destiny_id();
}
inline ::google::protobuf::uint32 proDestiny::destiny_id() const {
  return destiny_id_;
}
inline void proDestiny::set_destiny_id(::google::protobuf::uint32 value) {
  set_has_destiny_id();
  destiny_id_ = value;
}

// required uint32 type = 2;
inline bool proDestiny::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void proDestiny::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void proDestiny::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void proDestiny::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 proDestiny::type() const {
  return type_;
}
inline void proDestiny::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 level = 3;
inline bool proDestiny::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void proDestiny::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void proDestiny::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void proDestiny::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 proDestiny::level() const {
  return level_;
}
inline void proDestiny::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint32 reward_ts = 4;
inline bool proDestiny::has_reward_ts() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void proDestiny::set_has_reward_ts() {
  _has_bits_[0] |= 0x00000008u;
}
inline void proDestiny::clear_has_reward_ts() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void proDestiny::clear_reward_ts() {
  reward_ts_ = 0u;
  clear_has_reward_ts();
}
inline ::google::protobuf::uint32 proDestiny::reward_ts() const {
  return reward_ts_;
}
inline void proDestiny::set_reward_ts(::google::protobuf::uint32 value) {
  set_has_reward_ts();
  reward_ts_ = value;
}

// required uint32 num1 = 5;
inline bool proDestiny::has_num1() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void proDestiny::set_has_num1() {
  _has_bits_[0] |= 0x00000010u;
}
inline void proDestiny::clear_has_num1() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void proDestiny::clear_num1() {
  num1_ = 0u;
  clear_has_num1();
}
inline ::google::protobuf::uint32 proDestiny::num1() const {
  return num1_;
}
inline void proDestiny::set_num1(::google::protobuf::uint32 value) {
  set_has_num1();
  num1_ = value;
}

// optional uint32 num2 = 6;
inline bool proDestiny::has_num2() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void proDestiny::set_has_num2() {
  _has_bits_[0] |= 0x00000020u;
}
inline void proDestiny::clear_has_num2() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void proDestiny::clear_num2() {
  num2_ = 0u;
  clear_has_num2();
}
inline ::google::protobuf::uint32 proDestiny::num2() const {
  return num2_;
}
inline void proDestiny::set_num2(::google::protobuf::uint32 value) {
  set_has_num2();
  num2_ = value;
}

// optional uint32 num3 = 7;
inline bool proDestiny::has_num3() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void proDestiny::set_has_num3() {
  _has_bits_[0] |= 0x00000040u;
}
inline void proDestiny::clear_has_num3() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void proDestiny::clear_num3() {
  num3_ = 0u;
  clear_has_num3();
}
inline ::google::protobuf::uint32 proDestiny::num3() const {
  return num3_;
}
inline void proDestiny::set_num3(::google::protobuf::uint32 value) {
  set_has_num3();
  num3_ = value;
}

// optional uint32 num4 = 8;
inline bool proDestiny::has_num4() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void proDestiny::set_has_num4() {
  _has_bits_[0] |= 0x00000080u;
}
inline void proDestiny::clear_has_num4() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void proDestiny::clear_num4() {
  num4_ = 0u;
  clear_has_num4();
}
inline ::google::protobuf::uint32 proDestiny::num4() const {
  return num4_;
}
inline void proDestiny::set_num4(::google::protobuf::uint32 value) {
  set_has_num4();
  num4_ = value;
}

// optional uint32 num5 = 9;
inline bool proDestiny::has_num5() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void proDestiny::set_has_num5() {
  _has_bits_[0] |= 0x00000100u;
}
inline void proDestiny::clear_has_num5() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void proDestiny::clear_num5() {
  num5_ = 0u;
  clear_has_num5();
}
inline ::google::protobuf::uint32 proDestiny::num5() const {
  return num5_;
}
inline void proDestiny::set_num5(::google::protobuf::uint32 value) {
  set_has_num5();
  num5_ = value;
}

// optional uint32 num6 = 10;
inline bool proDestiny::has_num6() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void proDestiny::set_has_num6() {
  _has_bits_[0] |= 0x00000200u;
}
inline void proDestiny::clear_has_num6() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void proDestiny::clear_num6() {
  num6_ = 0u;
  clear_has_num6();
}
inline ::google::protobuf::uint32 proDestiny::num6() const {
  return num6_;
}
inline void proDestiny::set_num6(::google::protobuf::uint32 value) {
  set_has_num6();
  num6_ = value;
}

// -------------------------------------------------------------------

// proGetDestiny

// required uint32 user_id = 1;
inline bool proGetDestiny::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void proGetDestiny::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void proGetDestiny::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void proGetDestiny::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 proGetDestiny::user_id() const {
  return user_id_;
}
inline void proGetDestiny::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required uint32 destiny_id = 2;
inline bool proGetDestiny::has_destiny_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void proGetDestiny::set_has_destiny_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void proGetDestiny::clear_has_destiny_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void proGetDestiny::clear_destiny_id() {
  destiny_id_ = 0u;
  clear_has_destiny_id();
}
inline ::google::protobuf::uint32 proGetDestiny::destiny_id() const {
  return destiny_id_;
}
inline void proGetDestiny::set_destiny_id(::google::protobuf::uint32 value) {
  set_has_destiny_id();
  destiny_id_ = value;
}

// -------------------------------------------------------------------

// proGetDestinies

// required uint32 user_id = 1;
inline bool proGetDestinies::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void proGetDestinies::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void proGetDestinies::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void proGetDestinies::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 proGetDestinies::user_id() const {
  return user_id_;
}
inline void proGetDestinies::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional uint32 type = 2;
inline bool proGetDestinies::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void proGetDestinies::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void proGetDestinies::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void proGetDestinies::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 proGetDestinies::type() const {
  return type_;
}
inline void proGetDestinies::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// proSaveDestiny

// required uint32 user_id = 1;
inline bool proSaveDestiny::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void proSaveDestiny::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void proSaveDestiny::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void proSaveDestiny::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 proSaveDestiny::user_id() const {
  return user_id_;
}
inline void proSaveDestiny::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required .cache.proDestiny destiny = 2;
inline bool proSaveDestiny::has_destiny() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void proSaveDestiny::set_has_destiny() {
  _has_bits_[0] |= 0x00000002u;
}
inline void proSaveDestiny::clear_has_destiny() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void proSaveDestiny::clear_destiny() {
  if (destiny_ != NULL) destiny_->::cache::proDestiny::Clear();
  clear_has_destiny();
}
inline const ::cache::proDestiny& proSaveDestiny::destiny() const {
  return destiny_ != NULL ? *destiny_ : *default_instance_->destiny_;
}
inline ::cache::proDestiny* proSaveDestiny::mutable_destiny() {
  set_has_destiny();
  if (destiny_ == NULL) destiny_ = new ::cache::proDestiny;
  return destiny_;
}
inline ::cache::proDestiny* proSaveDestiny::release_destiny() {
  clear_has_destiny();
  ::cache::proDestiny* temp = destiny_;
  destiny_ = NULL;
  return temp;
}
inline void proSaveDestiny::set_allocated_destiny(::cache::proDestiny* destiny) {
  delete destiny_;
  destiny_ = destiny;
  if (destiny) {
    set_has_destiny();
  } else {
    clear_has_destiny();
  }
}

// -------------------------------------------------------------------

// proDestinySoul

// required uint32 soul_id = 1;
inline bool proDestinySoul::has_soul_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void proDestinySoul::set_has_soul_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void proDestinySoul::clear_has_soul_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void proDestinySoul::clear_soul_id() {
  soul_id_ = 0u;
  clear_has_soul_id();
}
inline ::google::protobuf::uint32 proDestinySoul::soul_id() const {
  return soul_id_;
}
inline void proDestinySoul::set_soul_id(::google::protobuf::uint32 value) {
  set_has_soul_id();
  soul_id_ = value;
}

// required uint32 num = 2;
inline bool proDestinySoul::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void proDestinySoul::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void proDestinySoul::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void proDestinySoul::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 proDestinySoul::num() const {
  return num_;
}
inline void proDestinySoul::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// proImproveDestiny

// required uint32 user_id = 1;
inline bool proImproveDestiny::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void proImproveDestiny::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void proImproveDestiny::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void proImproveDestiny::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 proImproveDestiny::user_id() const {
  return user_id_;
}
inline void proImproveDestiny::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
}

// repeated .cache.proDestinySoul consume_souls = 2;
inline int proImproveDestiny::consume_souls_size() const {
  return consume_souls_.size();
}
inline void proImproveDestiny::clear_consume_souls() {
  consume_souls_.Clear();
}
inline const ::cache::proDestinySoul& proImproveDestiny::consume_souls(int index) const {
  return consume_souls_.Get(index);
}
inline ::cache::proDestinySoul* proImproveDestiny::mutable_consume_souls(int index) {
  return consume_souls_.Mutable(index);
}
inline ::cache::proDestinySoul* proImproveDestiny::add_consume_souls() {
  return consume_souls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cache::proDestinySoul >&
proImproveDestiny::consume_souls() const {
  return consume_souls_;
}
inline ::google::protobuf::RepeatedPtrField< ::cache::proDestinySoul >*
proImproveDestiny::mutable_consume_souls() {
  return &consume_souls_;
}

// required .cache.proDestiny destiny = 3;
inline bool proImproveDestiny::has_destiny() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void proImproveDestiny::set_has_destiny() {
  _has_bits_[0] |= 0x00000004u;
}
inline void proImproveDestiny::clear_has_destiny() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void proImproveDestiny::clear_destiny() {
  if (destiny_ != NULL) destiny_->::cache::proDestiny::Clear();
  clear_has_destiny();
}
inline const ::cache::proDestiny& proImproveDestiny::destiny() const {
  return destiny_ != NULL ? *destiny_ : *default_instance_->destiny_;
}
inline ::cache::proDestiny* proImproveDestiny::mutable_destiny() {
  set_has_destiny();
  if (destiny_ == NULL) destiny_ = new ::cache::proDestiny;
  return destiny_;
}
inline ::cache::proDestiny* proImproveDestiny::release_destiny() {
  clear_has_destiny();
  ::cache::proDestiny* temp = destiny_;
  destiny_ = NULL;
  return temp;
}
inline void proImproveDestiny::set_allocated_destiny(::cache::proDestiny* destiny) {
  delete destiny_;
  destiny_ = destiny;
  if (destiny) {
    set_has_destiny();
  } else {
    clear_has_destiny();
  }
}

// -------------------------------------------------------------------

// proDestinyRes

// required uint32 code = 1;
inline bool proDestinyRes::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void proDestinyRes::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void proDestinyRes::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void proDestinyRes::clear_code() {
  code_ = 0u;
  clear_has_code();
}
inline ::google::protobuf::uint32 proDestinyRes::code() const {
  return code_;
}
inline void proDestinyRes::set_code(::google::protobuf::uint32 value) {
  set_has_code();
  code_ = value;
}

// optional .cache.proDestiny destiny = 2;
inline bool proDestinyRes::has_destiny() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void proDestinyRes::set_has_destiny() {
  _has_bits_[0] |= 0x00000002u;
}
inline void proDestinyRes::clear_has_destiny() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void proDestinyRes::clear_destiny() {
  if (destiny_ != NULL) destiny_->::cache::proDestiny::Clear();
  clear_has_destiny();
}
inline const ::cache::proDestiny& proDestinyRes::destiny() const {
  return destiny_ != NULL ? *destiny_ : *default_instance_->destiny_;
}
inline ::cache::proDestiny* proDestinyRes::mutable_destiny() {
  set_has_destiny();
  if (destiny_ == NULL) destiny_ = new ::cache::proDestiny;
  return destiny_;
}
inline ::cache::proDestiny* proDestinyRes::release_destiny() {
  clear_has_destiny();
  ::cache::proDestiny* temp = destiny_;
  destiny_ = NULL;
  return temp;
}
inline void proDestinyRes::set_allocated_destiny(::cache::proDestiny* destiny) {
  delete destiny_;
  destiny_ = destiny;
  if (destiny) {
    set_has_destiny();
  } else {
    clear_has_destiny();
  }
}

// -------------------------------------------------------------------

// proDestiniesRes

// required uint32 code = 1;
inline bool proDestiniesRes::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void proDestiniesRes::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void proDestiniesRes::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void proDestiniesRes::clear_code() {
  code_ = 0u;
  clear_has_code();
}
inline ::google::protobuf::uint32 proDestiniesRes::code() const {
  return code_;
}
inline void proDestiniesRes::set_code(::google::protobuf::uint32 value) {
  set_has_code();
  code_ = value;
}

// repeated .cache.proDestiny destinies = 2;
inline int proDestiniesRes::destinies_size() const {
  return destinies_.size();
}
inline void proDestiniesRes::clear_destinies() {
  destinies_.Clear();
}
inline const ::cache::proDestiny& proDestiniesRes::destinies(int index) const {
  return destinies_.Get(index);
}
inline ::cache::proDestiny* proDestiniesRes::mutable_destinies(int index) {
  return destinies_.Mutable(index);
}
inline ::cache::proDestiny* proDestiniesRes::add_destinies() {
  return destinies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cache::proDestiny >&
proDestiniesRes::destinies() const {
  return destinies_;
}
inline ::google::protobuf::RepeatedPtrField< ::cache::proDestiny >*
proDestiniesRes::mutable_destinies() {
  return &destinies_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cache

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_destiny_2eproto__INCLUDED
